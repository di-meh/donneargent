/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import { useEffect, useRef, type JSX } from 'react'
import { useGLTF } from '@react-three/drei'
import type { GLTF } from 'three-stdlib'
import { RapierRigidBody, RigidBody, vec3, type RigidBodyProps } from '@react-three/rapier'
import type { MoneyProps } from '../types'
import { Mesh, Position, Velocity } from '../../koota/traits'
import { useFrame } from '@react-three/fiber'

type GLTFResult = GLTF & {
  nodes: {
    stack: THREE.Mesh
  }
  materials: {}
}

export function Stack({entity, ...props}: MoneyProps): JSX.Element {
  const { nodes, materials } = useGLTF('/models/stack.glb') as unknown as GLTFResult
  const rbRef = useRef<RapierRigidBody>(null)
  const groupRef = useRef<THREE.Group>(null)
  const impulseApplied = useRef(false);
  const position = entity.get(Position);
  const velocity = entity.get(Velocity);

  useEffect(() => {
      if (!groupRef.current || !rbRef.current) return
      entity.add(Mesh(groupRef.current as THREE.Object3D));
      rbRef.current.setTranslation(vec3(position), true);
      return () => {
        entity.destroy();
      }
    }, [entity]);

  useFrame(() => {
    if (!rbRef.current) return;
    if (velocity && !impulseApplied.current && rbRef.current.mass() > 0) {
      rbRef.current.applyImpulse(velocity, true);
      const randomTorque = {x: (Math.random() - 1)/20, y:(Math.random() - 1)/20, z: (Math.random() - 1)/20};
      rbRef.current.applyTorqueImpulse(randomTorque, true);
      impulseApplied.current = true;
    }
  });

  return (
    <RigidBody ref={rbRef} type="dynamic" colliders="cuboid" name="stack" {...props}>
        <group scale={[3,3,3]} ref={groupRef} dispose={null}>
        <mesh
            name="stack"
            castShadow
            receiveShadow
            geometry={nodes.stack.geometry}
            material={nodes.stack.material}
            position={[0, -0.063, 0]}
        />
        </group>
    </RigidBody>
  )
}

useGLTF.preload('/models/stack.glb')
