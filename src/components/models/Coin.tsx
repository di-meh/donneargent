/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { useEffect, useRef, type JSX } from "react";
import { useGLTF } from "@react-three/drei";
import type { GLTF } from "three-stdlib";
import {
	RapierRigidBody,
	RigidBody,
	type RigidBodyProps,
	vec3,
} from "@react-three/rapier";
import type { Entity } from "koota";
import { Mesh, Position, Velocity } from "../../koota/traits";
import { useFrame, useThree } from "@react-three/fiber";
import type { MoneyProps } from "../types";

type GLTFResult = GLTF & {
	nodes: {
		cylinder: THREE.Mesh;
	};
	materials: {};
};

export function Coin({ entity, ...props }: MoneyProps): JSX.Element {
	const { nodes, materials } = useGLTF(
		"/models/coin.glb",
	) as unknown as GLTFResult;
	const rbRef = useRef<RapierRigidBody>(null);
	const groupRef = useRef<THREE.Group>(null);
	const impulseApplied = useRef(false);
	const position = entity.get(Position);
	const velocity = entity.get(Velocity);

	useEffect(() => {
		if (!groupRef.current || !rbRef.current) return;
		entity.add(Mesh(groupRef.current as THREE.Object3D));
		rbRef.current.setTranslation(vec3(position), true);
		return () => {
			entity.destroy();
		};
	}, [entity]);

	useFrame(() => {
		if (!rbRef.current) return;
		if (velocity && !impulseApplied.current && rbRef.current.mass() > 0) {
			rbRef.current.applyImpulse(velocity, true);
			const randomTorque = {
				x: (Math.random() - 1) / 200,
				y: (Math.random() - 1) / 200,
				z: (Math.random() - 1) / 200,
			};
			rbRef.current.applyTorqueImpulse(randomTorque, true);
			impulseApplied.current = true;
		}
	});

	return (
		<RigidBody
			ref={rbRef}
			type="dynamic"
			colliders="hull"
			name="coin"
			{...props}
		>
			<group ref={groupRef} scale={[0.5, 2, 0.5]} dispose={null}>
				<mesh
					castShadow
					receiveShadow
					geometry={nodes.cylinder.geometry}
					material={nodes.cylinder.material}
				/>
			</group>
		</RigidBody>
	);
}

useGLTF.preload("/models/coin.glb");
